<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"8.0.0-rc.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="纵有疾风起，人生不言弃！">
<meta property="og:type" content="website">
<meta property="og:title" content="Mr">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mr">
<meta property="og:description" content="纵有疾风起，人生不言弃！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jun-Gui">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Mr</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fd5e70c0f8bc67c5a280145fd40d6226";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mr</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">设计模式与算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-25 23:24:07 / 修改时间：23:23:06" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:07+08:00">2020-09-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.算法：解题方案的准确而完整的描述，是一系列解决问题的清晰指令。<br>①有穷性（Finiteness）：算法的有穷性是指算法必须能在执行有限个步骤之后终止；</p>
<p>②确切性(Definiteness)：算法的每一步骤必须有确切的定义；</p>
<p>③输入项(Input)：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输 入是指算法本身定出了初始条件；</p>
<p>④输出项(Output)：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没 有输出的算法是毫无意义的；</p>
<p>⑤可行性(Effectiveness)：算法中执行的任何计算步骤都是可以被分解为基本的可执行 的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）；</p>
<p>⑥高效性(High efficiency)：执行速度快，占用资源少；</p>
<p>⑦健壮性(Robustness)：对数据响应正确。</p>
<p>时间复杂度概念：一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<p>2.常用排序<br>①冒泡排序（Bubble Sort）：这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。<br>if data_set[i] &gt; data_set[i+1]: #每次将i与i+1比较，每次大循环将最大的放最后。小的逐渐放在最前<br>tmp = data_set[i]<br>data_set[i] = data_set[i+1]<br>data_set[i+1] = tmp</p>
<p>②选择排序：在不断缩小的范围内选出最小值放在前面。<br>smallest_num_index = 0 #初始列表最小值,默认为第一个<br>for j in range(len(data_set)): #每次确定一个最小数，从头到尾确定<br>for i in range(j,len(data_set)): #从已确定数后一位开始<br>if data_set[i] &lt; data_set[smallest_num_index]: #当前值 比之前选出来的最小值 还要小,那就把它换成最小值<br>smallest_num_index = i #记录最小值的位置，然后互换给当前位置J，每次即可确定一个最小值<br>loop_count +=1</p>
<p>③插入排序(Insertion Sort)：将列表分为2部分，左边为排序好的部分，右边为未排序的部分，循环整个列表，<br>每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。<br>一开始，已经排序的元素序列为空。</p>
<p>for i in range(len(data_set)):<br>while i &gt; 0 and data_set[i] &lt; data_set[i-1]: #如果后一个小，就放前一位，类似于插牌<br>tmp = data_set[i]<br>data_set[i] = data_set[i-1]<br>data_set[i-1] = tmp<br>i -= 1</p>
<p>④快速排序（quick sort）：首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，<br>所有比它大的数都放到它后面。</p>
<p>不稳定：多个关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序可能变化</p>
<p>⑤二叉树：边的上端节点称为父节点，下端称为子节点。</p>
<p>⑥堆排序：堆分为最大堆和最小堆，其实就是完全二叉树。最大堆要求节点的元素都要大于其孩子，最小堆要求节点元素都小于其左右孩子，<br>两者对左右孩子的大小关系不做任何要求，<br>堆排序就是把堆顶的最大数取出再排序，再取出</p>
<p>⑦希尔排序（shell sort）：插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。<br>不断缩小增量的间隔组成的元素进行大小排序，最后一次直接插入排序。<br>2018/03/15 周四</p>
<p>常用设计模式学习<br>设计模式：代码设计经验的总结，创建型、结构型和行为型3大类</p>
<p>①创建型模式：对对象的创建进行研究。<br>简单工厂模式（Simple Factory）；</p>
<p>工厂方法模式（Factory Method）；</p>
<p>抽象工厂模式（Abstract Factory）；</p>
<p>创建者模式（Builder）；</p>
<p>原型模式（Prototype）；</p>
<p>单例模式（Singleton）。<br>②结构型模式：对象的组成以及对象之间的依赖关系。<br>外观模式（Facade）；</p>
<p>适配器模式（Adapter）；</p>
<p>代理模式（Proxy）；</p>
<p>装饰模式（Decorator）；</p>
<p>桥模式（Bridge）；</p>
<p>组合模式（Composite）；</p>
<p>享元模式（Flyweight）<br>③行为型模式：在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了。<br>模板方法模式（Template Method）；</p>
<p>观察者模式（Observer）；</p>
<p>状态模式（State）；</p>
<p>策略模式（Strategy）；</p>
<p>职责链模式（Chain of Responsibility）；</p>
<p>命令模式（Command）；</p>
<p>访问者模式（Visitor）；</p>
<p>调停者模式（Mediator）；</p>
<p>备忘录模式（Memento）；</p>
<p>迭代器模式（Iterator）；</p>
<p>解释器模式（Interpreter）。</p>
<p>2.设计模式的六大原则<br>①开闭原则（Open Close Principle）</p>
<p>对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码。<br>所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p>
<p>②里氏代换原则（Liskov Substitution Principle）</p>
<p>面向对象设计的基本原则之一。即任何基类可以出现的地方，子类一定可以出现。<br>LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。<br>里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。<br>而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>3、依赖倒转原则（Dependence Inversion Principle）</p>
<p>这个是开闭原则的基础，具体内容：是对接口编程，依赖于抽象而不依赖于具体。</p>
<p>4、接口隔离原则（Interface Segregation Principle）</p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，<br>从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。<br>所以上文中多次出现：降低依赖，降低耦合。</p>
<p>5、迪米特法则（最少知道原则）（Demeter Principle）</p>
<p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p>6、合成复用原则（Composite Reuse Principle）</p>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>2018/03/16 周五</p>
<p>设计三大类模式<br>2018/03/17 周六</p>
<p>一. 创建型模式<br>1.工厂模式<br>意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类。<br>①简单工厂模式：一个接口类负责决定创建哪个ShapeFactory的子类，即一个工厂。<br>总结：创建好多个产品的类后，写一个接口类对用哪个产品的类进行逻辑判断。</p>
<p>②工厂方法模式：对每一个产品都有相应的工厂，客户端判断使用哪个接口（工厂）。<br>把简单工厂抽象为一个Factory类（可以是抽象类和接口），制定了一些规范，具体的生产由其子类工厂完成。<br>总结：写一个接口类，然后再写继承的子类，子类里的方法对应不同的产品类</p>
<p>③抽象工厂模式：工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。<br>两个重要的概念：产品族和产品等级。<br>特点：使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构。即一个工厂创建一族产品。<br>功能：为一系列相关对象或相互依赖的对象创建一个接口。切换产品族的时候，切换工厂即可。<br>客户端使用抽象工厂来创建需要的对象，而根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。<br>总结：同一等级结构的产品有一个总类，对应不同族写不同的子类继承。写好多个等级结构后，再写一个总工厂类，<br>不同族继承不同的子工厂类，子工厂类里创建该族的一族产品。<br>最后写一个抽象工厂类，执行创建的动作。输入不同族产品即可创建不同族。</p>
<p>2.建造者模式<br>意图：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>基本思想：某类产品的构建由很多复杂组件组成；（类比一族产品）<br>这些组件中的某些细节不同，构建出的产品表象会略有不同；（类比不同族的工厂）<br>通过一个指挥者按照产品的创建步骤来一步步执行产品的创建；（类比工厂的创建过程）<br>当需要创建不同的产品时，只需要派生一个具体的建造者，重写相应的组件构建方法即可。（切换工厂）<br>总结：写一个基类，子类继承时细节不同，再写一个指挥者的类，执行创建。</p>
<p>3.单例模式<br>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>总结：只有唯一的一个实例，后者会覆盖前面的。通过cls._instance绑定，唯一化实例</p>
<pre><code>二.结构型模式</code></pre><p>1.适配器模式：<br>意图：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>应用场景：希望复用一些现存的类，但是接口又与复用环境要求不一致。<br>总结：新写一个类，类的方法指向现存的类的方法，即可转换。</p>
<p>2.桥接模式：<br>概述：某些类型由于自身的逻辑，它具有两个或多个维度的变化，<br>意图：将抽象部分与实现部分分离，使它们都可以独立的变化。<br>效果及实现要点：<br>①Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。<br>②所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意它们，从而获得不同路上的不同汽车。<br>③Bridge模式有时候类似于多继承方案，但是多继承方案往往违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。<br>④Bridge模式的应用一般在“两个非常强的变化维度”。注意的是，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。<br>总结：自由组配不同对象与不同实现，每种组合都有可能实现。这点与创建型模式——抽象工厂不同，抽象工厂只能创建一族的产品。</p>
<p>3.组合模式<br>意图：将对象组合成树形结构以表示“部分-整体”的层次结构。用户对单个对象和组合对象的使用具有一致性。<br>用途：比如总店和分店，在总店购买时，积分也一样累加在分店卡上。<br>总结：写总店的对象的类时，写一个储存列表的方法，在实例时把分店加到里面，在写刷卡方法时，循环列表取出刷卡。<br>总店刷卡时，即可累加积分到分店上。从而单个对象（总店）和组合对象（总店和分店）使用（刷卡积分）一致。</p>
<p>4.外观模式<br>意图：定义了一个高层接口,为子系统中的一组接口提供一个一致的界面，这个接口使得这一子系统更加容易使用。<br>概述：Facade 可以提供一个简单的缺省视图（用于接口），需要定制（改写继承）则越过facade层。<br>不同层之间建立外观模式，定义各自的facade接口，作为子系统中每层的入口点，它们仅通过facade进行通讯。<br>总结：为多层次的子类的不同层各写一个方法，归在一个总类下。</p>
<p>5.享元模式<br>意图：运用共享技术有效地支持大量细粒度的对象。<br>概述：<br>①抽象享元角色（Flyweight）：<br>此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口或抽象类。<br>那些需要外部状态(External State)的操作可以通过方法的参数传入。<br>抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。</p>
<p>②具体享元(ConcreteFlyweight)角色：<br>实现抽象享元角色所规定的接口。如果有内部状态的话，必须负责为内部状态提供存储空间。<br>享元对象的内部状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享。<br>有时候具体享元角色又叫做单纯具体享元角色，因为复合享元角色是由单纯具体享元角色通过复合而成的。</p>
<p>③复合享元(UnsharableFlyweight)角色：<br>复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。<br>复合享元角色又称做不可共享的享元对象。这个角色一般很少使用。</p>
<p>④享元工厂(FlyweightFactoiy)角色：<br>本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。<br>当一个客户端对象请求一个享元对象的时候，享元工厂角色需要检查系统中是否已经有一个符合要求的享元对象，<br>如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，<br>享元工厂角色就应当创建一个新的合适的享元对象。</p>
<p>⑤客户端(Client)角色：<br>本角色还需要自行存储所有享元对象的外部状态。</p>
<p>⑥内部状态与外部状态：<br>在享元对象内部并且不会随着环境改变而改变的共享部分，可以称之为享元对象的内部状态，<br>反之随着环境改变而改变的，不可共享的状态称之为外部状态。<br>总结：写一个抽象基类（抽象享元），再继承子类（具体享元），实例化子类时（享元工厂）处理一下（删除相同实例的外部状态）。<br>那么可以用相对较少的共享对象取代很多组对象。</p>
<p>6.代理模式<br>意图：为其他对象提供一种代理以控制对这个对象的访问。<br>主要解决：在直接访问对象时带来的问题。如买火车票，路远不去火车站买，去代售点买即可。<br>总结：写一个代理类，其方法指向被代理的类的方法。<br>缺点：增加了一层代理，请求处理时可能会速度变慢。<br>使用场景：<br>①远程代理。<br>②虚拟代理。<br>③Copy-on-Write 代理。<br>④保护（Protect or Access）代理。<br>⑤Cache代理。<br>⑥防火墙（Firewall）代理。<br>⑦同步化（Synchronization）代理。<br>⑧智能引用（Smart Reference）代理。</p>
<pre><code>3三. 行为型模式</code></pre><p>1.模板方法模式<br>概述：一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现。<br>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中（重写）。行为（次数，数量）由父类控制，子类实现。<br>何时使用：一些方法通用，却在每一个子类都重新写了这一方法。<br>总结：在父类中写好全部方法（次序、数量），子类继承时重写部分方法，通过覆盖某些步骤，<br>使得相同的算法框架可以有不同的执行结果。</p>
<p>2.责任链模式<br>意图：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。<br>将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<br>总结：写一个基类，基类中要有从一个对象转下一个对象的方法，def successor(self,successor):<br>self._successor = successor<br>该方法的功能就是把另一个对象通过successor（）传递进来（进这个对象类中）。<br>在需要传下去时，写else self._successor.handle(request)即可。<br>最后一个对象不需要传递。<br>实例化时要把链子通过successor串起来。</p>
<p>3.观察者模式 又名发布-订阅（Publish/Subscribe）模式<br>意图：定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。<br>总结：写一个基类，包含基本的添加、解除、通知等需要的方法，其中通知方法遍历使用被观察者类的被通知方法；<br>然后写一个继承的观察者类，里面包括传入信息，执行通知方法的方法；<br>再写几个被观察者类，有被通知方法；<br>最后实例时，添加被观察者到观察者的列表中，输入msg即可触发通知方法。</p>
<p>4.策略模式<br>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换（即可随时更换）。<br>如何解决：将这些算法封装成一个一个的类，任意地替换。<br>关键代码：实现同一个接口。<br>总结：原本要更换算法的话，需要重新实例，要想同一个实例，需要在类里面定义一个重新指向算法的方法。<br>先写好几个算法，写接口时，除了有执行算法的方法，还需有重新指向另一个算法的方法，<br>更换时输入算法类的名字即可更换。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">存储过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-25 23:24:07" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:07+08:00">2020-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-31 20:01:43" itemprop="dateModified" datetime="2020-07-31T20:01:43+08:00">2020-07-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>205</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、MYSQL存储过程中的关键语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F; 声明语句结束符，用于区分;  结尾处还原结束符DELIMITER ;</span><br><span class="line">CEATE PROCEDURE demo_in_parameter(IN p_in int) 声明存储过程 </span><br><span class="line">BEGIN …. END 存储过程开始和结束符号 </span><br><span class="line">SET @p_in&#x3D;1 变量赋值 </span><br><span class="line">DECLARE l_int int unsigned default 4000000; 变量定义</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/window/" class="post-title-link" itemprop="url">window</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-25 23:24:07" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:07+08:00">2020-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-31 20:01:43" itemprop="dateModified" datetime="2020-07-31T20:01:43+08:00">2020-07-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>183</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、进入控制台 cmd<br>2、输入命令：netstat -ano，列出所有端口的情况。在列表中我们观察被占用的端口，比如是1224，首先找到它；<br>3、查看被占用端口对应的PID，输入命令：netstat -aon|findstr “8081”，即PID,这里是9088；<br>4、 继续输入tasklist|findstr “9088”，回车</p>
<p>5、杀掉进程 TASKKILL /F /PID XXXX </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/vue/" class="post-title-link" itemprop="url">vue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-25 23:24:07 / 修改时间：23:23:06" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:07+08:00">2020-09-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>439</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>切换淘宝镜像：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>全局安装vue脚手架 cnpm install -g vue-cli<br>安装指定木目录下 vue init webpack</p>
<p>引入IVIEW组件，在当前项目的cmd窗口输入 cnpm install iview –save-dev ，<br>easy-table-vue组件cnpm install vue-easytable –save-dev</p>
<p>  安装入axios，cnpm install axios –save-dev<br>  安装vant组件 npm install vant –save:这是完整写法</p>
<p>标签说明：</p>
<p><template></template></p>
<p>　　可以在<template></template>标签中添加自定义标签，并且可以使用vue中特有的指令</p>
<script></script>

<p>　　可以在此处编写js代码，但如果此vue文件是一个组件则需要添加”export default{}”代码将该组件导出</p>
<style></style>

<p>　　可以在此处编写css代码，若希望该css样式只作用在该vue组件中，则需要改成<style scoped></style></p>
<p>v-bind 缩写缩写 </p>
<!-- 完整语法 -->   <a v-bind:href="url">...</a>
<!-- 缩写 -->         <a :href="url">...</a>

<p>v-on 缩写</p>
<!-- 完整语法 -->         <a v-on:click="doSomething">...</a>
<!-- 缩写 -->        <a @click="doSomething">...</a>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/springboot%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/springboot%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">springboot知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-25 23:24:07 / 修改时间：23:23:06" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:07+08:00">2020-09-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、注解详解（配备了完善的释义）——</p>
<p>@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：</p>
<p>@Configuration?，@EnableAutoConfiguration?和 @ComponentScan?三个配置。</p>
<p>@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。<br>在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。<br>比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。</p>
<p>@Controller：用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），<br>一般这个注解在类中，通常方法需要配合注解@RequestMapping。</p>
<p>@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。</p>
<p>@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。</p>
<p>@EnableAutoConfiguration：SpringBoot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。<br>例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。<br>你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。<br>如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</p>
<p>@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，<br>并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。<br>可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。<br>如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。</p>
<p>@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，<br>建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p>
<p>@Import：用来导入其他配置类。</p>
<p>@ImportResource：用来加载xml配置文件。</p>
<p>@Autowired：自动导入依赖的bean</p>
<p>@Service：一般用于修饰service层的组件</p>
<p>@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，<br>同时也不需要为它们提供XML配置项。</p>
<p>@Bean：用@Bean标注方法等价于XML中配置的bean。</p>
<p>@Value：注入Spring boot application.properties配置的属性的值。示例代码：</p>
<p>@Inject：等价于默认的@Autowired，只是没有required属性；</p>
<p>@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
<p>@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p>
<p>@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，<br>完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。</p>
<p>@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入<br>，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p>
<p>@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。</p>
<p>二、注解列表如下</p>
<p>@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中</p>
<p>@ComponentScan：让spring Boot扫描到Configuration类并把它加入到程序上下文。</p>
<p>@Configuration ：等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p>
<p>@EnableAutoConfiguration ：自动配置。</p>
<p>@ComponentScan ：组件扫描，可自动发现和装配一些Bean。</p>
<p>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。</p>
<p>@RestController：注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p>
<p>@Autowired：自动导入。</p>
<p>@PathVariable：获取参数。</p>
<p>@JsonBackReference：解决嵌套外链问题。</p>
<p>@RepositoryRestResourcepublic：配合spring-boot-starter-data-rest使用。</p>
<p>三、JPA注解</p>
<p>@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略</p>
<p>@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。</p>
<p>@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。</p>
<p>@Column：如果字段名与列名相同，则可以省略。</p>
<p>@Id：表示该属性为主键。</p>
<p>@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是<br>sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。</p>
<p>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，<br>sequenceName为数据库的sequence名称，两个名称可以一致。</p>
<p>@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,<br>ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式</p>
<p>@JsonIgnore：作用是json序列化时将Java?bean中的一些属性忽略掉,序列化和反序列化都受影响。</p>
<p>@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p>
<p>@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。</p>
<p>四、springMVC相关注解<br>@RequestMapping<br>可以在控制器类的级别和/或其中的方法的级别上使用。<br>在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上。<br>之后你还可以另外添加方法级别的注解来进一步指定到处理方法的映射关系。</p>
<p>@RequestParam<br>可以使用@RequestParam注解将请求参数绑定到你控制器的方法参数上<br>可以设定该参数是否必须，设定默认值等等</p>
<p>@RequestHeader<br>可以把Request请求header部分的值绑定到方法的参数上。</p>
<p>@CookieValue<br>可以把Request header中关于cookie的值绑定到方法的参数上。</p>
<p>@PathVariable<br>用于rest风格请求，将路径上的变量绑定到方法的参数上</p>
<p>@SessionAttributes<br>默认情况下Spring MVC将模型中的数据存储到request域中。<br>当一个请求结束后，数据就失效了。<br>而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。<br>该注解定义在类的上面</p>
<p>@SessionAttribute<br>取session中的数据，并赋值给方法中的参数</p>
<p>@ModelAttribute注释参数<br>接受参数，并存到model中（实际上不定义也可以接受对象并存到model中）<br>使用它可以定义该参数存到model中的key值</p>
<p>@ModelAttribute注释方法<br>被@ModelAttribute注释的方法会在此controller每个方法执行前被执行<br>因此对于一个controller映射多个URL的用法来说，要谨慎使用。<br>执行该方法会先把model传过来，并把session中的值绑定到model中<br>之后执行的@RequestMapping方法，使用的model就是这个model</p>
<p>@ResponseBody<br>@ResponseBody是作用在方法上的<br>@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中<br>一般在异步获取数据时使用【也就是AJAX】，返回json数据</p>
<p>@RequestBody<br>定义在方法的参数前面<br>@requestBody注解常用来处理content-type不是默认的application/x-www-form-urlcoded编码的内容<br>比如说：application/json或者是application/xml等</p>
<p>五、全局异常处理</p>
<p>@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。</p>
<p>@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p>
<p>六、项目中具体配置解析和使用环境</p>
<p>@MappedSuperclass：<br>1.@MappedSuperclass 注解使用在父类上面，是用来标识父类的</p>
<p>2.@MappedSuperclass 标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够映射在其子类对用的数据库表中</p>
<p>3.@MappedSuperclass 标识的类不能再有@Entity或@Table注解</p>
<p>@Column：</p>
<p>1.当实体的属性与其映射的数据库表的列不同名时需要使用@Column标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。</p>
<p>2.@Column 标注的常用属性是name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique、nullable、length、precision等。<br>具体如下：</p>
<p>1 name属性：name属性定义了被标注字段在数据库表中所对应字段的名称</p>
<p>2 unique属性：unique属性表示该字段是否为唯一标识，默认为false，如果表中有一个字段需要唯一标识，则既可以使用该标记，<br>也可以使用@Table注解中的@UniqueConstraint</p>
<p>3 nullable属性：nullable属性表示该字段是否可以为null值，默认为true</p>
<p>4 insertable属性：insertable属性表示在使用”INSERT”语句插入数据时，是否需要插入该字段的值</p>
<p>5 updateable属性：updateable属性表示在使用”UPDATE”语句插入数据时，是否需要更新该字段的值</p>
<p>6 insertable和updateable属性：一般多用于只读的属性，例如主键和外键等，这些字段通常是自动生成的</p>
<p>7 columnDefinition属性：columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，<br>该属性没有必要使用</p>
<p> 8 table属性：table属性定义了包含当前字段的表名</p>
<p> 9 length属性：length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符</p>
<p>precision属性和scale属性：precision属性和scale属性一起表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数</p>
<p> 具体如下：<br>1.double类型将在数据库中映射为double类型，precision和scale属性无效<br>2.double类型若在columnDefinition属性中指定数字类型为decimal并指定精度，则最终以columnDefinition为准<br>3.BigDecimal类型在数据库中映射为decimal类型，precision和scale属性有效<br>4.precision和scale属性只在BigDecimal类型中有效</p>
<p>3.@Column 标注的columnDefinition属性: 表示该字段在数据库中的实际类型.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,<br>但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR,<br>如果要将 String 类型映射到特定数据库的 BLOB 或TEXT字段类型.</p>
<p>4.@Column标注也可置于属性的getter方法之前</p>
<p>@Getter和@Setter（Lombok）</p>
<p>@Setter：注解在属性上；为属性提供 setting 方法 @Getter：注解在属性上；为属性提供 getting 方法</p>
<p>@Data：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法</p>
<p>@Setter：注解在属性上；为属性提供 setting 方法</p>
<p>@Getter：注解在属性上；为属性提供 getting 方法</p>
<p>@Log4j2 ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象，和@Log4j注解类似</p>
<p>@NoArgsConstructor：注解在类上；为类提供一个无参的构造方法</p>
<p>@AllArgsConstructor：注解在类上；为类提供一个全参的构造方法</p>
<p>@EqualsAndHashCode:默认情况下，会使用所有非瞬态(non-transient)和非静态(non-static)字段来生成equals和hascode方法，也可以指定具体使用哪些属性。</p>
<p>@toString:生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p>
<p> @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor<br> 无参构造器、部分参数构造器、全参构造器，当我们需要重载多个构造器的时候，只能自己手写了</p>
<p> @NonNull：注解在属性上，如果注解了，就必须不能为Null</p>
<p> @val:注解在属性上，如果注解了，就是设置为final类型，可查看源码的注释知道</p>
<p>当你在执行各种持久化方法的时候，实体的状态会随之改变，状态的改变会引发不同的生命周期事件。这些事件可以使用不同的注释符来指示发生时的回调函数。</p>
<p>@javax.persistence.PostLoad：加载后。</p>
<p>@javax.persistence.PrePersist：持久化前。</p>
<p>@javax.persistence.PostPersist：持久化后。</p>
<p>@javax.persistence.PreUpdate：更新前。</p>
<p>@javax.persistence.PostUpdate：更新后。</p>
<p>@javax.persistence.PreRemove：删除前。</p>
<p>@javax.persistence.PostRemove：删除后。</p>
<p>1）数据库查询</p>
<p>@PostLoad事件在下列情况下触发：</p>
<p>执行EntityManager.find()或getreference()方法载入一个实体后。</p>
<p>执行JPQL查询后。</p>
<p>EntityManager.refresh()方法被调用后。</p>
<p>2）数据库插入</p>
<p>@PrePersist和@PostPersist事件在实体对象插入到数据库的过程中发生：</p>
<p>@PrePersist事件在调用persist()方法后立刻发生，此时的数据还没有真正插入进数据库。</p>
<p>@PostPersist事件在数据已经插入进数据库后发生。</p>
<p>3）数据库更新</p>
<p>@PreUpdate和@PostUpdate事件的触发由更新实体引起：</p>
<p>@PreUpdate事件在实体的状态同步到数据库之前触发，此时的数据还没有真正更新到数据库。</p>
<p>@PostUpdate事件在实体的状态同步到数据库之后触发，同步在事务提交时发生。</p>
<p>4）数据库删除</p>
<p>@PreRemove和@PostRemove事件的触发由删除实体引起：</p>
<p>@PreRemove事件在实体从数据库删除之前触发，即在调用remove()方法删除时发生，此时的数据还没有真正从数据库中删除。</p>
<p>@PostRemove事件在实体从数据库中删除后触发。</p>
<p>==========================================================<br>在处理模型数据是control向页面传递数据是可以直接存储在ModelAndView、Map、ModelMap、Model中（存储在request域当中）</p>
<p>在不通过映射实现页面跳转可以通过配置&lt;mvc:view-controller patn=”xxurl” view =”xxxt跳转后的页面”&gt;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/Springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/Springboot/" class="post-title-link" itemprop="url">Springboot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-25 23:24:07 / 修改时间：23:23:06" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:07+08:00">2020-09-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>383</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-spring-boot-demo"><a href="#1-spring-boot-demo" class="headerlink" title="1.spring-boot-demo"></a>1.spring-boot-demo</h3><p> <a href="https://github.com/xkcoding/spring-boot-demo" target="_blank" rel="noopener">https://github.com/xkcoding/spring-boot-demo</a> </p>
<h3 id="2-SpringBoot-Labs"><a href="#2-SpringBoot-Labs" class="headerlink" title="2.SpringBoot-Labs"></a>2.SpringBoot-Labs</h3><p> <a href="https://github.com/YunaiV/SpringBoot-Labs" target="_blank" rel="noopener">https://github.com/YunaiV/SpringBoot-Labs</a> ！SpringBoot-Labs-03</p>
<h3 id="3-springboot-guide"><a href="#3-springboot-guide" class="headerlink" title="3.springboot-guide"></a>3.springboot-guide</h3><p> <a href="https://github.com/Snailclimb/springboot-guide" target="_blank" rel="noopener">https://github.com/Snailclimb/springboot-guide</a>  ！ springboot-guide-04</p>
<h3 id="4-springBoot"><a href="#4-springBoot" class="headerlink" title="4.springBoot"></a>4.springBoot</h3><p> <a href="https://github.com/527515025/springBoot" target="_blank" rel="noopener">https://github.com/527515025/springBoot</a>  ！spring boot 04</p>
<p> 1 、mvn package clean -Dmaven.test.skip=true  解释：把之前打过的包通通干掉。</p>
<p>2、mvn package -Dmaven.test.skip=true        解释：重新打包。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/redis/" class="post-title-link" itemprop="url">redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-25 23:24:07 / 修改时间：23:23:06" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:07+08:00">2020-09-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、redis的数据类型<br>String(字符串) SET 和 GET 命令。键为 runoob，对应的值为 菜鸟教程 SET str “hello” 、GET str    二进制安全    可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</p>
<p>Hash(字典)    键值对集合,即编程语言中的Map类型 HSET hashData  field1 “Hello”、HGET runoob field1     适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)<br>适用于:存储、读取、修改用户属性</p>
<p>List(列表)    链表(双向链表)    增删快,提供了操作某一段元素的API适用于:1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</p>
<p>Set(集合)    哈希表实现,元素不重复    1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作<br>适用于:1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</p>
<p>Sorted Set(有序集合) 将Set中的元素增加一个权重参数score,元素按score有序排列    数据插入集合时,已经进行天然排序<br>适用于:1、排行榜 2、带权重的消息队列</p>
<p>2、事务<br>1.5、事务操作的基本命令<br>multi : 设置事务开始<br>exec : 执行事务<br>discard : 放弃事务<br>watch : 监控键值，如果键值被修改或删除，后面的一个事务就不会执行<br>    redis使用watch来提供乐观锁定，类似于CAS(check-and-set)<br>    watch可以被调用多次<br>    当EXEC被调用后，所有的之前被监视的键值会被取消监视，不管事务是否被取消或执行。并且当客户端连接丢失的时候，所有东西都会被取消监视</p>
<p>unwatch : 取消watch</p>
<p>3、 发布订阅<br>（1）publish : 发布消息，格式是： publish channel 消息<br>（2）subscribe : 订阅消息，格式是：subscribe channel, 可以是多个channel<br>（3）psubscribe : 订阅消息，格式是：psubscribe channel, 支持glob风格的通配符<br>（4）unsubscribe : 取消订阅，格式是：unsubscribe channel,不指定频道表示取消所有subscribe命令的订阅<br>（5）punsubscribe: : 取消订阅，格式是：punsubscribe channel,不指定频道表示取消所有的punsubscribe命令的订阅，注意这里匹配模式的时候，是不会将通配符展开的，是严格进行字符串匹配的，比如：punsubscribe * 是无法退订 c1.<em>的，必须严格使用punsubscribe c1.</em> 才可以。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/react/" class="post-title-link" itemprop="url">react</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-25 23:24:07 / 修改时间：23:23:06" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:07+08:00">2020-09-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>创建react<br>淘宝镜像资源： npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>npm install -g create-react-app<br> create-react-app my-app<br>进入项目路径<br>cd my-app/<br>npm start</p>
<p>不可逆操作 显示配置文件  npm run  eject</p>
<p>自定义eslint<br>修改packge.json文件中</p>
<p>{ extendsreact-app}</p>
<p>添加.eslintrc文件 </p>
<p>按需映入<br>安装组件<br>npm install babel-plugin-import -save</p>
<p>npm install antd -save</p>
<p>引入less<br>npm install less less-loader -D</p>
<p>=============================</p>
<p>npm isntall axios –save</p>
<p>rfc回车 生成无状态组件</p>
<p>rcc回车即可生成有状态组件</p>
<p>=============================<br>介绍 webpack-bundle-analyzer 这个插件来分析SPA应用<br>npm install –save-dev webpack-bundle-analyzer<br>在webpack的plugins中配置： new BundleAnalyzerPlugin()<br>在package.json 中增加：?”analyz”:?”NODE_ENV=production npm_config_report=true npm run build”</p>
<p>=================================<br>以前使用JS 定义一个变量使用 var 现在用 const：const div = document.createElement(‘div’);</p>
<p>ReactDOM.render(…) 是渲染方法，所有的 js,html 都可通过它进行渲染绘制，他有两个参数，内容和渲染目标 js 对象。<br>内容就是要在渲染目标中显示的东西，可以是一个React 部件，也可以是一段HTML或TEXT文本。渲染目标JS对象，<br>就是一个DIV或TABEL,或TD 等HTML的节点对象。<br>ReactDOM.render(<App />, div);</p>
<p>unmountComponentAtNode() 这个方法是解除渲染挂载，作用和 render 刚好相反，也就清空一个渲染目标中的 React 部件或 html 内容。<br>ReactDOM.unmountComponentAtNode(div);</p>
<p>表单采用</p>
<p>defaltValue 多选按钮 defaltCheck</p>
<p>节点通过refs对象获取 <span refs="aa">    this.refs[‘aa’]</p>
<p>======================================================================================<br>组件生命周期 - 创建阶段(Mounting)<br>特点：该阶段的函数只执行一次<br>constructor()<br>作用：1 获取props 2 初始化state<br>说明：通过 constructor() 的参数props获取<br>设置state和props</p>
<p>componentWillMount()<br>说明：组件被挂载到页面之前调用，其在render()之前被调用，因此在这方法里同步地设置状态将不会触发重渲染<br>注意：无法获取页面中的DOM对象<br>注意：可以调用 setState() 方法来改变状态值<br>用途：发送ajax请求获取数据</p>
<p>componentDidMount(){}<br>1 组件已经挂载到页面中<br>2 可以进行DOM操作，比如：获取到组件内部的DOM对象<br>3 可以发送请求获取数据<br>4 可以通过 setState() 修改状态的值</p>
<p>注意：在这里修改状态会重新渲染</p>
<p>组件生命周期 - 运行阶段（Updating）<br>特点：该阶段的函数执行多次<br>说明：每当组件的props或者state改变的时候，都会触发运行阶段的函数</p>
<p>componentWillReceiveProps()<br>说明：组件接受到新的props前触发这个方法<br>参数：当前组件props值<br>可以通过 this.props 获取到上一次的值<br>使用：若你需要响应属性的改变，可以通过对比this.props和nextProps并在该方法中使用this.setState()处理状态改变<br>注意：修改state不会触发该方法</p>
<p>shouldComponentUpdate()<br>作用：根据这个方法的返回值决定是否重新渲染组件，返回true重新渲染，否则不渲染<br>优势：通过某个条件渲染组件，降低组件渲染频率，提升组件性能<br>说明：如果返回值为false，那么，后续render()方法不会被调用<br>注意：这个方法必须返回布尔值！！！<br>场景：根据随机数决定是否渲染组件</p>
<p>componentWillUpdate()<br>作用：组件将要更新<br>参数：最新的属性和状态对象<br>注意：不能修改状态 否则会循环渲染</p>
<p>componentDidUpdate()<br>作用：组件已经被更新</p>
<p>参数：旧的属性和状态对象</p>
<p>组件生命周期 - 卸载阶段（Unmounting）<br>组件销毁阶段：组件卸载期间，函数比较单一，只有一个函数，这个函数也有一个显著的特点：组件一辈子只能执行依次！<br>使用说明：只要组件不再被渲染到页面中，那么这个方法就会被调用（ 渲染到页面中 -&gt; 不再渲染到页面中 ）<br>componentWillUnmount()<br>作用：在卸载组件的时候，执行清理工作，比如</p>
<p>1 清除定时器<br>2 清除componentDidMount创建的DOM对象</p>
<p>es6中引入扩展运算符（…），它用于把一个数组转化为用逗号分隔的参数序列，<br>它常用在不定参数个数时的函数调用，数组合并等情形。<br>因为typeScript是es6的超集，所以typeScript也支持扩展运算符。</p>
<hr>
<p>// 父组件<br>class Parent extends React.Component {<br>  testRef=(ref)=&gt;{<br>    this.child = ref<br>    console.log(ref) // -&gt; 获取整个Child元素<br>  }<br>  handleClick=()=&gt;{<br>    alert(this.child.state.info) // -&gt; 通过this.child可以拿到child所有状态和方法<br>  }<br>  render() {<br>    return <div><br>      <Child onRef={this.testRef} /><br>      <button onClick={this.handleClick}>父组件按钮</button><br>    </div><br>  }<br>}<br>// 子组件<br>class Child extends React.Component {<br>  constructor(props) {<br>    super(props)<br>    this.state = {<br>      info:’快点击子组件按钮哈哈哈’<br>    }<br>  }<br>  componentDidMount(){<br>    this.props.onRef(this)<br>    console.log(this) // -&gt;将child传递给this.props.onRef()方法<br>  }<br>  handleChildClick=()=&gt;{<br>    this.setState({info:’通过父组件按钮获取到子组件信息啦啦啦’})<br>  }<br>  render(){<br>    return <button onClick={this.handleChildClick}>子组件按钮</button><br>  }<br>}<br>原理：<br>当在子组件中调用onRef函数时，正在调用从父组件传递的函数。this.props.onRef（this）这里的参数指向子组件本身，<br>父组件接收该引用作为第一个参数：onRef = {ref =&gt;（this.child = ref）}然后它使用this.child保存引用。<br>之后，可以在父组件内访问整个子组件实例，并且可以调用子组件函数。</p>
<p>父组件获取子组件数据可以利用props把获取数据的方法传递给子组件，<br>父组件调用子组件方法李用onRef={(ref) =&gt; { this.child = ref }}把当前组件的this传到子组件中，<br>再在父组件中利用( this.child.子组件的方法) 从而实现父组件调用子组件的方法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/nginx/" class="post-title-link" itemprop="url">nginx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-25 23:24:07 / 修改时间：23:23:06" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:07+08:00">2020-09-25</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="正向代理："><a href="#正向代理：" class="headerlink" title="正向代理："></a>正向代理：</h4><p>我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，<br>此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，</p>
<p>代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p>
<h4 id="反向代理："><a href="#反向代理：" class="headerlink" title="反向代理："></a>反向代理：</h4><p>多个客户端给服务器发送的请求，nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。<br>此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，nginx扮演的就是一个反向代理角色</p>
<h4 id="负载均衡："><a href="#负载均衡：" class="headerlink" title="负载均衡："></a>负载均衡：</h4><p>客户端发送的、nginx反向代理服务器接收到的请求数量，就是我们说的负载量<br>请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则<br>将服务器接收到的请求按照规则分发的过程，称为负载均衡</p>
<p>########### 每个指令必须有分号结束。#################<br>#user administrator administrators;  #配置用户或者组，默认为nobody nobody。<br>#worker_processes 2;  #允许生成的进程数，默认为1<br>#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址<br>error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg<br>events {<br>    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on<br>    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off<br>    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport<br>    worker_connections  1024;    #最大连接数，默认为512<br>}<br>http {<br>    include       mime.types;   #文件扩展名与文件类型映射表<br>    default_type  application/octet-stream; #默认文件类型，默认为text/plain<br>    #access_log off; #取消服务日志<br>    log_format myFormat ‘$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for’; #自定义格式<br>    access_log log/access.log myFormat;  #combined为日志格式的默认值<br>    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。<br>    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。<br>    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。</p>
<pre><code>upstream mysvr {   
  server 127.0.0.1:7878;
  server 192.168.10.121:3333 backup;  #热备
}
error_page 404 https://www.baidu.com; #错误页
server {
    keepalive_requests 120; #单连接请求上限次数。
    listen       4545;   #监听端口
    server_name  127.0.0.1;   #监听地址       
    location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
       #root path;  #根目录
       #index vv.txt;  #设置默认页
       proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表
       deny 127.0.0.1;  #拒绝的ip
       allow 172.18.5.54; #允许的ip           
    } 
}</code></pre><p>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/25/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jun-Gui">
      <meta itemprop="description" content="纵有疾风起，人生不言弃！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/Mysql/" class="post-title-link" itemprop="url">Mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-25 23:24:06" itemprop="dateCreated datePublished" datetime="2020-09-25T23:24:06+08:00">2020-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-13 20:24:38" itemprop="dateModified" datetime="2020-07-13T20:24:38+08:00">2020-07-13</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>事务的基本特征原子性（atomicity）：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。一致性（consistency）：数据库总数从一个一致性的状态转换到另一个一致性的状态。隔离性（isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p>
<p>事务的隔离级别，mysql默认的隔离级别是什么？读未提交(Read uncommitted)，一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。读已提交(Read committed)，一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。可重复读(Repeatable read)，就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。串行(Serializable)，是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。Mysql的默认隔离级别是Repeatable read。</p>
<p>说一说脏读、不可重复读、幻读脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据；不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致；幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）；</p>
<p>数据表类型有哪些答：MyIASM、InnoDB、HEAP、ISAM、MERGE、DBD以及Gemeni(一般只知道前两者即可)</p>
<p>innodb引擎的4大特性答：插入缓冲(insert buffer)；二次写(double write)；自适应哈希索引(ahi)；预读(read ahead)</p>
<p>InnoDB引擎的行锁是通过加在什么上实现的？答：基于索引；</p>
<p>Mysql中的myisam与innodb的区别，至少五点InooDB支持事务，而MyISAM不支持事务；InnoDB支持行级锁，而MyISAM支持表级锁；InnoDB支持MVCC，而MyISAM不支持；InnoDB支持外键，而MyISAM不支持；InnoDB不支持全文索引，而MyISAM支持；InnoDB不能通过直接拷贝表文件的方法拷贝表到另外一台机器， myisam 支持；InnoDB表支持多种行格式， myisam 不支持；InnoDB是索引组织表， myisam 是堆表；</p>
<p>myisam与innodb select count(*)哪个更快，为什么答：myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</p>
<p>数据库三大范式第一范式：第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.</p>
<p>说一说你能想到的sql语句优化，至少五种避免select *，将需要查找的字段列出来；使用连接（join）来代替子查询；拆分大的delete或insert语句；使用limit对查询结果的记录进行限定；用 exists 代替 in 是一个好的选择；用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤；不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引尽量避免在where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描；尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描；尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描；</p>
<p>说一说你能想到的表结构优化，至少五种永远为每张表设置一个ID (所有建表的时候不设置主键的程序猿都应该被辞退)；选择正确的存储引擎 ;使用可存下数据的最小的数据类型，整型 &lt; date,time &lt; char,varchar &lt; blob；使用简单的数据类型，整型比字符处理开销更小，因为字符串的比较更复杂。如，int类型存储时间类型，bigint类型转ip函数；使用合理的字段属性长度，固定长度的表会更快。使用enum、char而不是varchar；尽可能使用not null定义字段(给空字段设置默认值)；尽量少用text;给频繁使用和查询的字段建立合适的索引；</p>
<p>说几个mysql中你常用的函数答：sum、count 、avg、min、max</p>
<p>说几个你除了增删改查之外在mysql中常用的命令答：Explain、describe、show、truncate</p>
<p>说几个除了增删改查之外常用的关键字答：distinct、limit、offset、order by、union、union all、between、group by；</p>
<p>union、union all的区别对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录；对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回；从效率上说，UNION ALL 要比UNION快很多</p>
<p>varchar(100)和varchar(200)的区别答：varchar(100)最多存放100个字符，varchar(200)最多存放200个字符，varchar(100)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)</p>
<p>varchar(20)和int(20)中的20含义一样吗答：不一样，前者表示最多存放20个字符，后者表示最多显示20个字符，但是存储空间还是占4字节存储，存储范围不变；<br>什么是存储过程？用什么来调用？答：存储过程是一个预编译的SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL ，使用存储过程比单纯SQL 语句执行要快。可以用一个命令对象来调用存储过程。</p>
<p>什么是触发器？触发器的作用？答：触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
<p>存储过程与触发器的区别答：触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p>
<p>索引的作用？和它的优点缺点是什么？答：索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。<br>MySQL主要的索引类型普通索引：是最基本的索引，它没有任何限制；唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一；主键索引：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值；组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合；全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较，mysql中MyISAM支持全文索引而InnoDB不支持；</p>
<p>使用like ‘a%’ 、like’%a’、like’%a%’查询时是否会使用索引答：’a%’会，其他两个不会；</p>
<p>使用索引注意事项索引不会包含有NULL的列，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的；使用短索引，对串列进行索引，如果可以就应该指定一个前缀长度；短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作；mysql查询只使用一个索引，因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引；注意like，上文已经提到；不要在列上进行运算；不使用NOT IN 、&lt;&gt;、！=操作，但&lt;,&lt;=，=，&gt;,&gt;=,BETWEEN,IN是可以用到索引的；索引要建立在经常进行select操作的字段上；索引要建立在值比较唯一的字段上；对于那些定义为text、image和bit数据类型的列不应该增加索引；在where和join中出现的列需要建立索引；如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引；在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用；</p>
<p>说一说什么是外键，优缺点答：外键指的是外键约束，目的是保持数据一致性，完整性，控制存储在外键表中的数据。使两张表形成关联，外键只能引用外表中列的值；优点：由数据库自身保证数据一致性，完整性，更可靠，因为程序很难100％保证数据的完整性，而用外键即使在数据库服务器当机或者出现其他问题的时候，也能够最大限度的保证数据的一致性和完整性。有主外键的数据库设计可以增加ER图的可读性，这点在数据库设计时非常重要。外键在一定程度上说明的业务逻辑，会使设计周到具体全面。缺点：可以用触发器或应用程序保证数据的完整性；过分强调或者说使用外键会平添开发难度，导致表过多，更改业务困难，扩展困难等问题；不用外键时数据管理简单，操作方便，性能高（导入导出等操作，在insert, update, delete 数据的时候更快）；</p>
<p>在什么时候你会选择使用外键，为什么答：在我的业务逻辑非常简单，业务一旦确定不会轻易更改，表结构简单，业务量小的时候我会选择使用外键。因为当不符合以上条件的时候，外键会影响业务的扩展和修改，当数据量庞大时，会严重影响增删改查的效率。</p>
<p>什么叫视图？游标是什么？视图是一种虚拟的表，具有和物理表相同的功能；可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
<p>mysql有没有rowid？答：没有，InnoDB如果没有定义主键，内部会生成一个主键编号rowid ，但是无法查询到。在平时InnoDB建表的时候我们最好自己确定主键，防止每次插入数据前数据库会去生成rowid。</p>
<p>mysql怎么在查询时给查出来的数据设置一个自增的序号？set @i=0;SELECT (@i:=@i+1) 别名 FROM table, (SELECT @i:=0) AS 别名 ;</p>
<p>如何使用explain优化sql和索引？explain sql ;table：显示这一行的数据是关于哪张表的；type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL；all: full table scan ;MySQL将遍历全表以找到匹配的行；index ： index scan; index 和 all的区别在于index类型只遍历索引；range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，&lt; ,&gt;等查询；ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型；如果将主键置于where列表中，MySQL就能将该查询转化为一个常量；possible_keys：显示可能应用在这张表中的索引；如果为空，没有可能的索引；可以为相关的域从WHERE语句中选择一个合适的语句；key： 实际使用的索引；如果为NULL，则没有使用索引；很少的情况下，MySQL会选择优化不足的索引；这种情况下，可以在SELECT语句中使用USE INDEX(indexname)来强制使用一个索引或者用IGNORE INDEX(indexname)来强制MySQL忽略索引key_len：使用的索引的长度；在不损失精确性的情况下，长度越短越好；ref：显示索引的哪一列被使用了，如果可能的话，是一个常数；rows：MySQL认为必须检查的用来返回请求数据的行数；Extra：关于MySQL如何解析查询的额外信息；</p>
<p>1.需要数据库表1.学生表<br>Student(SID,Sname,Sage,Ssex) –SID 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别</p>
<p>2.课程表<br>Course(CID,Cname,TID) –CID –课程编号,Cname 课程名称,TID 教师编号<br>3.教师表<br>Teacher(TID,Tname) –TID 教师编号,Tname 教师姓名<br>4.成绩表<br>SC(SID,CID,score) –SID 学生编号,CID 课程编号,score 分数</p>
<p>添加测试数据1.学生表<br>create table Student(SID varchar(10),Sname nvarchar(10),Sage datetime,Ssex nvarchar(10));<br>insert into Student values(‘01’ , ‘赵雷’ , ‘1990-01-01’ , ‘男’);<br>insert into Student values(‘02’ , ‘钱电’ , ‘1990-12-21’ , ‘男’);<br>insert into Student values(‘03’ , ‘孙风’ , ‘1990-05-20’ , ‘男’);<br>insert into Student values(‘04’ , ‘李云’ , ‘1990-08-06’ , ‘男’);<br>insert into Student values(‘05’ , ‘周梅’ , ‘1991-12-01’ , ‘女’);<br>insert into Student values(‘06’ , ‘吴兰’ , ‘1992-03-01’ , ‘女’);<br>insert into Student values(‘07’ , ‘郑竹’ , ‘1989-07-01’ , ‘女’);<br>insert into Student values(‘08’ , ‘王菊’ , ‘1990-01-20’ , ‘女’);</p>
<p>2.课程表<br>create table Course(CID varchar(10),Cname nvarchar(10),TID varchar(10));<br>insert into Course values(‘01’ , ‘语文’ , ‘02’);<br>insert into Course values(‘02’ , ‘数学’ , ‘01’);<br>insert into Course values(‘03’ , ‘英语’ , ‘03’);</p>
<p>3.教师表<br>create table Teacher(TID varchar(10),Tname nvarchar(10));<br>insert into Teacher values(‘01’ , ‘张三’);<br>insert into Teacher values(‘02’ , ‘李四’);<br>insert into Teacher values(‘03’ , ‘王五’);</p>
<p>4.成绩表<br>create table SC(SID varchar(10),CID varchar(10),score decimal(18,1));<br>insert into SC values(‘01’ , ‘01’ , 80);<br>insert into SC values(‘01’ , ‘02’ , 90);<br>insert into SC values(‘01’ , ‘03’ , 99);<br>insert into SC values(‘02’ , ‘01’ , 70);<br>insert into SC values(‘02’ , ‘02’ , 60);<br>insert into SC values(‘02’ , ‘03’ , 80);<br>insert into SC values(‘03’ , ‘01’ , 80);<br>insert into SC values(‘03’ , ‘02’ , 80);<br>insert into SC values(‘03’ , ‘03’ , 80);<br>insert into SC values(‘04’ , ‘01’ , 50);<br>insert into SC values(‘04’ , ‘02’ , 30);<br>insert into SC values(‘04’ , ‘03’ , 20);<br>insert into SC values(‘05’ , ‘01’ , 76);<br>insert into SC values(‘05’ , ‘02’ , 87);<br>insert into SC values(‘06’ , ‘01’ , 31);<br>insert into SC values(‘06’ , ‘03’ , 34);<br>insert into SC values(‘07’ , ‘02’ , 89);<br>insert into SC values(‘07’ , ‘03’ , 98);</p>
<p>–1、查询”01”课程比”02”课程成绩高的学生的信息及课程分数</p>
<p>–1.1、查询同时存在”01”课程和”02”课程的情况<br>select a.* , b.score 课程01的分数,c.score 课程02的分数 from Student a , SC b , SC c<br>where a.SID = b.SID and a.SID = c.SID and b.CID = ‘01’ and c.CID = ‘02’ and b.score &gt; c.score</p>
<p>–1.2、查询同时存在”01”课程和”02”课程的情况和存在”01”课程但可能不存在”02”课程的情况(不存在时显示为null)(以下存在相同内容时不再解释)<br>select a.* , b.score 课程01的分数,c.score 课程02的分数 from Student a<br>left join SC b on a.SID = b.SID and b.CID = ‘01’<br>left join SC c on a.SID = c.SID and c.CID = ‘02’<br>where b.score &gt; isnull(c.score)</p>
<p>–2、查询”01”课程比”02”课程成绩低的学生的信息及课程分数</p>
<p>–2.1、查询同时存在”01”课程和”02”课程的情况<br>select a.* , b.score 课程01的分数 ,c.score 课程02的分数 from Student a , SC b , SC c<br>where a.SID = b.SID and a.SID = c.SID and b.CID = ‘01’ and c.CID = ‘02’ and b.score &lt; c.score</p>
<p>–2.2、查询同时存在”01”课程和”02”课程的情况和不存在”01”课程但存在”02”课程的情况<br>select a.* , b.score 课程01的分数 ,c.score 课程02的分数 from Student a<br>left join SC b on a.SID = b.SID and b.CID = ‘01’<br>left join SC c on a.SID = c.SID and c.CID = ‘02’<br>where isnull(b.score,0) &lt; c.score</p>
<p>–3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩<br>select a.SID , a.Sname , cast(avg(b.score) as decimal(18,2)) avg_score<br>from Student a , sc b<br>where a.SID = b.SID<br>group by a.SID , a.Sname<br>having cast(avg(b.score) as decimal(18,2)) &gt;= 60<br>order by a.SID</p>
<p>–4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩</p>
<p>–4.1、查询在sc表存在成绩的学生信息的SQL语句。<br>select a.SID , a.Sname , cast(avg(b.score) as decimal(18,2)) avg_score<br>from Student a , sc b<br>where a.SID = b.SID<br>group by a.SID , a.Sname<br>having cast(avg(b.score) as decimal(18,2)) &lt; 60<br>order by a.SID</p>
<p>–4.2、查询在sc表中不存在成绩的学生信息的SQL语句。<br>select a.SID , a.Sname , isnull(cast(avg(b.score) as decimal(18,2)),0) avg_score<br>from Student a left join sc b<br>on a.SID = b.SID<br>group by a.SID , a.Sname<br>having isnull(cast(avg(b.score) as decimal(18,2)),0) &lt; 60<br>order by a.SID</p>
<p>–5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩</p>
<p>–5.1、查询所有有成绩的SQL。<br>select a.SID 学生编号 , a.Sname 学生姓名 , count(b.CID) 选课总数, sum(score) 所有课程的总成绩<br>from Student a , SC b<br>where a.SID = b.SID<br>group by a.SID,a.Sname<br>order by a.SID</p>
<p>–5.2、查询所有(包括有成绩和无成绩)的SQL。<br>select a.SID 学生编号 , a.Sname 学生姓名 , count(b.CID) 选课总数, sum(score) 所有课程的总成绩<br>from Student a left join SC b<br>on a.SID = b.SID<br>group by a.SID,a.Sname<br>order by a.SID</p>
<p>–6、查询”李”姓老师的数量<br>–方法1<br>select count(Tname) 李姓老师的数量 from Teacher where Tname like ‘李%’<br>–方法2<br>select count(Tname) 李姓老师的数量 from Teacher where left(Tname,1) = ‘李’</p>
<p>–7、查询学过”张三”老师授课的同学的信息<br>select distinct Student.* from Student , SC , Course , Teacher<br>where Student.SID = SC.SID and SC.CID = Course.CID and Course.TID = Teacher.TID and Teacher.Tname = ‘张三’<br>order by Student.SID</p>
<p>–8、查询没学过”张三”老师授课的同学的信息<br>select m.* from Student m where SID not in (select distinct SC.SID from SC , Course , Teacher where SC.CID = Course.CID and Course.TID = Teacher.TID and Teacher.Tname = ‘张三’) order by m.SID</p>
<p>–9、查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息<br>–方法1<br>select Student.* from Student , SC where Student.SID = SC.SID and SC.CID = ‘01’ and exists (Select 1 from SC SC_2 where SC_2.SID = SC.SID and SC_2.CID = ‘02’) order by Student.SID<br>–方法2<br>select Student.* from Student , SC where Student.SID = SC.SID and SC.CID = ‘02’ and exists (Select 1 from SC SC_2 where SC_2.SID = SC.SID and SC_2.CID = ‘01’) order by Student.SID<br>–方法3<br>select m.* from Student m where SID in<br>(<br>select SID from<br>(<br>select distinct SID from SC where CID = ‘01’</p>
<p>union all</p>
<p>select distinct SID from SC where CID = ‘02’</p>
<p>) t group by SID having count(1) = 2</p>
<p>)</p>
<p>order by m.SID</p>
<p>–10、查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息</p>
<p>–方法1</p>
<p>select Student.* from Student , SC where Student.SID = SC.SID and SC.CID = ‘01’ and not exists (Select 1 from SC SC_2 where SC_2.SID = SC.SID and SC_2.CID = ‘02’) order by Student.SID</p>
<p>–方法2<br>select Student.* from Student , SC where Student.SID = SC.SID and SC.CID = ‘01’ and Student.SID not in (Select SC_2.SID from SC SC_2 where SC_2.SID = SC.SID and SC_2.CID = ‘02’) order by Student.SID</p>
<p>–11、查询没有学全所有课程的同学的信息<br>–11.1、<br>select Student.*<br>from Student , SC<br>where Student.SID = SC.SID<br>group by Student.SID , Student.Sname , Student.Sage , Student.Ssex having count(CID) &lt; (select count(CID) from Course)</p>
<p>–11.2<br>select Student.*<br>from Student left join SC<br>on Student.SID = SC.SID<br>group by Student.SID , Student.Sname , Student.Sage , Student.Ssex having count(CID) &lt; (select count(CID) from Course)</p>
<p>–12、查询至少有一门课与学号为”01”的同学所学相同的同学的信息<br>select distinct Student.* from Student , SC where Student.SID = SC.SID and SC.CID in (select CID from SC where SID = ‘01’) and Student.SID &lt;&gt; ‘01’</p>
<p>–13、查询和”01”号的同学学习的课程完全相同的其他同学的信息<br>select Student.* from Student where SID in<br>(select distinct SC.SID from SC where SID &lt;&gt; ‘01’ and SC.CID in (select distinct CID from SC where SID = ‘01’)<br>group by SC.SID having count(1) = (select count(1) from SC where SID=’01’))</p>
<p>–14、查询没学过”张三”老师讲授的任一门课程的学生姓名<br>select student.* from student where student.SID not in<br>(select distinct sc.SID from sc , course , teacher where sc.CID = course.CID and course.TID = teacher.TID and teacher.tname = ‘张三’)<br>order by student.SID</p>
<p>–15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩<br>select student.SID , student.sname , cast(avg(score) as decimal(18,2)) avg_score from student , sc<br>where student.SID = SC.SID and student.SID in (select SID from SC where score &lt; 60 group by SID having count(1) &gt;= 2)<br>group by student.SID , student.sname</p>
<p>–16、检索”01”课程分数小于60，按分数降序排列的学生信息<br>select student.* , sc.CID , sc.score from student , sc<br>where student.SID = SC.SID and sc.score &lt; 60 and sc.CID = ‘01’<br>order by sc.score desc</p>
<p>–17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩–17.1 SQL 2000 静态<br>select a.SID 学生编号 , a.Sname 学生姓名 ,<br>max(case c.Cname when ‘语文’ then b.score else null end) 语文 ,<br>max(case c.Cname when ‘数学’ then b.score else null end) 数学 ,<br>max(case c.Cname when ‘英语’ then b.score else null end) 英语 ,<br>cast(avg(b.score) as decimal(18,2)) 平均分<br>from Student a<br>left join SC b on a.SID = b.SID<br>left join Course c on b.CID = c.CID<br>group by a.SID , a.Sname<br>order by 平均分 desc</p>
<p>–17.2 SQL 2000 动态<br>declare @sql nvarchar(4000)<br>set @sql = ‘select a.SID ‘ + ‘学生编号’ + ‘ , a.Sname ‘ + ‘学生姓名’<br>select @sql = @sql + ‘,max(case c.Cname when ‘’’+Cname+’’’ then b.score else null end) ‘+Cname+’ ‘<br>from (select distinct Cname from Course) as t<br>set @sql = @sql + ‘ , cast(avg(b.score) as decimal(18,2)) ‘ + ‘平均分’ + ‘ from Student a left join SC b on a.SID = b.SID left join Course c on b.CID = c.CID<br>group by a.SID , a.Sname order by ‘ + ‘平均分’ + ‘ desc’<br>exec(@sql)</p>
<p>–18、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率<br>–及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90</p>
<p>–方法1<br>select m.CID 课程编号 , m.Cname 课程名称 ,<br>max(n.score) 最高分 ,<br>min(n.score) 最低分 ,<br>cast(avg(n.score) as decimal(18,2)) 平均分 ,<br>cast((select count(1) from SC where CID = m.CID and score &gt;= 60)<em>100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 及格率 ,<br>cast((select count(1) from SC where CID = m.CID and score &gt;= 70 and score &lt; 80 )</em>100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 中等率 ,<br>cast((select count(1) from SC where CID = m.CID and score &gt;= 80 and score &lt; 90 )<em>100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 优良率 ,<br>cast((select count(1) from SC where CID = m.CID and score &gt;= 90)</em>100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 优秀率<br>from Course m , SC n<br>where m.CID = n.CID<br>group by m.CID , m.Cname<br>order by m.CID</p>
<p>–方法2<br>select m.CID 课程编号 , m.Cname 课程名称 ,<br>(select max(score) from SC where CID = m.CID) 最高分 ,<br>(select min(score) from SC where CID = m.CID) 最低分 ,<br>(select cast(avg(score) as decimal(18,2)) from SC where CID = m.CID) 平均分 ,<br>cast((select count(1) from SC where CID = m.CID and score &gt;= 60)<em>100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 及格率,<br>cast((select count(1) from SC where CID = m.CID and score &gt;= 70 and score &lt; 80 )</em>100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 中等率 ,<br>cast((select count(1) from SC where CID = m.CID and score &gt;= 80 and score &lt; 90 )<em>100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 优良率 ,<br>cast((select count(1) from SC where CID = m.CID and score &gt;= 90)</em>100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 优秀率<br>from Course m<br>order by m.CID</p>
<p>–19、按各科成绩进行排序，并显示排名–19.1 sql 2000用子查询完成</p>
<p>–Score重复时保留名次空缺<br>select t.* , px = (select count(1) from SC where CID = t.CID and score &gt; t.score) + 1 from sc t order by t.cid , px</p>
<p>–Score重复时合并名次<br>select t.* , px = (select count(distinct score) from SC where CID = t.CID and score &gt;= t.score) from sc t order by t.cid , px</p>
<p>–19.2 sql 2005用rank,DENSE_RANK完成</p>
<p>–Score重复时保留名次空缺(rank完成)<br>select t.* , px = rank() over(partition by cid order by score desc) from sc t order by t.CID , px</p>
<p>–Score重复时合并名次(DENSE_RANK完成)<br>select t.* , px = DENSE_RANK() over(partition by cid order by score desc) from sc t order by t.CID , px</p>
<p>–20、查询学生的总成绩并进行排名–20.1 查询学生的总成绩<br>select m.SID 学生编号 ,<br>m.Sname 学生姓名 ,<br>isnull(sum(score),0) 总成绩<br>from Student m left join SC n on m.SID = n.SID<br>group by m.SID , m.Sname<br>order by 总成绩 desc</p>
<p>–20.2 查询学生的总成绩并进行排名，sql 2000用子查询完成，分总分重复时保留名次空缺和不保留名次空缺两种。<br>select t1.* , px = (select count(1) from<br>(<br>select m.SID 学生编号 ,<br>m.Sname 学生姓名 ,<br>isnull(sum(score),0) 总成绩<br>from Student m left join SC n on m.SID = n.SID<br>group by m.SID , m.Sname<br>) t2 where 总成绩 &gt; t1.总成绩) + 1 from<br>(<br>select m.SID 学生编号 ,<br>m.Sname 学生姓名 ,<br>isnull(sum(score),0) 总成绩<br>from Student m left join SC n on m.SID = n.SID<br>group by m.SID , m.Sname<br>) t1<br>order by px<br>select t1.* , px = (select count(distinct 总成绩) from<br>(<br>select m.SID 学生编号 ,<br>m.Sname 学生姓名 ,<br>isnull(sum(score),0) 总成绩<br>from Student m left join SC n on m.SID = n.SID<br>group by m.SID , m.Sname<br>) t2 where 总成绩 &gt;= t1.总成绩) from<br>(<br>select m.SID 学生编号 ,<br>m.Sname 学生姓名 ,<br>isnull(sum(score),0) 总成绩<br>from Student m left join SC n on m.SID = n.SID<br>group by m.SID , m.Sname<br>) t1<br>order by px</p>
<p>–20.3 查询学生的总成绩并进行排名，sql 2005用rank,DENSE_RANK完成，分总分重复时保留名次空缺和不保留名次空缺两种。<br>select t.* , px = rank() over(order by 总成绩 desc) from<br>(<br>select m.SID 学生编号 ,<br>m.Sname 学生姓名 ,<br>isnull(sum(score),0) 总成绩<br>from Student m left join SC n on m.SID = n.SID<br>group by m.SID , m.Sname<br>) t<br>order by px<br>select t.* , px = DENSE_RANK() over(order by 总成绩 desc) from<br>(<br>select m.SID 学生编号 ,<br>m.Sname 学生姓名 ,<br>isnull(sum(score),0) 总成绩<br>from Student m left join SC n on m.SID = n.SID<br>group by m.SID , m.Sname<br>) t<br>order by px</p>
<p>–21、查询不同老师所教不同课程平均分从高到低显示<br>select m.TID , m.Tname , cast(avg(o.score) as decimal(18,2)) avg_score<br>from Teacher m , Course n , SC o<br>where m.TID = n.TID and n.CID = o.CID<br>group by m.TID , m.Tname<br>order by avg_score desc</p>
<p>–22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩–22.1 sql 2000用子查询完成<br>–Score重复时保留名次空缺<br>select * from (select t.* , px = (select count(1) from SC where CID = t.CID and score &gt; t.score) + 1 from sc t) m where px between 2 and 3 order by m.cid , m.px</p>
<p>–Score重复时合并名次<br>select * from (select t.* , px = (select count(distinct score) from SC where CID = t.CID and score &gt;= t.score) from sc t) m where px between 2 and 3 order by m.cid , m.px</p>
<p>–22.2 sql 2005用rank,DENSE_RANK完成</p>
<p>–Score重复时保留名次空缺(rank完成)<br>select * from (select t.* , px = rank() over(partition by cid order by score desc) from sc t) m where px between 2 and 3 order by m.CID , m.px</p>
<p>–Score重复时合并名次(DENSE_RANK完成)<br>select * from (select t.* , px = DENSE_RANK() over(partition by cid order by score desc) from sc t) m where px between 2 and 3 order by m.CID , m.px</p>
<p>–23、统计各科成绩各分数段人数：课程编号,课程名称, 100-85 , 85-70 , 70-60 , 0-60 及所占百分比 –23.1 统计各科成绩各分数段人数：课程编号,课程名称, 100-85 , 85-70 , 70-60 , 0-60</p>
<p>–横向显示<br>select Course.CID 课程编号 , Cname as 课程名称 ,<br>sum(case when score &gt;= 85 then 1 else 0 end) 85-100 ,<br>sum(case when score &gt;= 70 and score &lt; 85 then 1 else 0 end) 70-85 ,<br>sum(case when score &gt;= 60 and score &lt; 70 then 1 else 0 end) 60-70 ,<br>sum(case when score &lt; 60 then 1 else 0 end) 0-60<br>from sc , Course<br>where SC.CID = Course.CID<br>group by Course.CID , Course.Cname<br>order by Course.CID</p>
<p>–纵向显示1(显示存在的分数段)<br>select m.CID 课程编号 , m.Cname 课程名称 , 分数段 = (<br>case when n.score &gt;= 85 then ‘85-100’<br>when n.score &gt;= 70 and n.score &lt; 85 then ‘70-85’<br>when n.score &gt;= 60 and n.score &lt; 70 then ‘60-70’<br>else ‘0-60’<br>end) ,<br>count(1) 数量<br>from Course m , sc n<br>where m.CID = n.CID<br>group by m.CID , m.Cname , (<br>case when n.score &gt;= 85 then ‘85-100’<br>when n.score &gt;= 70 and n.score &lt; 85 then ‘70-85’<br>when n.score &gt;= 60 and n.score &lt; 70 then ‘60-70’<br>else ‘0-60’<br>end)<br>order by m.CID , m.Cname , 分数段</p>
<p>–纵向显示2(显示存在的分数段，不存在的分数段用0显示)</p>
<p>select m.CID 课程编号 , m.Cname 课程名称 , 分数段 = (</p>
<p>case when n.score &gt;= 85 then ‘85-100’</p>
<p>when n.score &gt;= 70 and n.score &lt; 85 then ‘70-85’</p>
<p>when n.score &gt;= 60 and n.score &lt; 70 then ‘60-70’</p>
<p>else ‘0-60’</p>
<p>end) ,</p>
<p>count(1) 数量</p>
<p>from Course m , sc n</p>
<p>where m.CID = n.CID</p>
<p>group by all m.CID , m.Cname , (</p>
<p>case when n.score &gt;= 85 then ‘85-100’</p>
<p>when n.score &gt;= 70 and n.score &lt; 85 then ‘70-85’</p>
<p>when n.score &gt;= 60 and n.score &lt; 70 then ‘60-70’</p>
<p>else ‘0-60’</p>
<p>end)</p>
<p>order by m.CID , m.Cname , 分数段</p>
<p>–23.2 统计各科成绩各分数段人数：课程编号,课程名称, 100-85 , 85-70 , 70-60 , &lt;60 及所占百分比</p>
<p>–横向显示</p>
<p>select m.CID 课程编号, m.Cname 课程名称,</p>
<p>(select count(1) from SC where CID = m.CID and score &lt; 60) 0-60 ,</p>
<p>cast((select count(1) from SC where CID = m.CID and score &lt; 60)*100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 百分比 ,</p>
<p>(select count(1) from SC where CID = m.CID and score &gt;= 60 and score &lt; 70) 60-70 ,</p>
<p>cast((select count(1) from SC where CID = m.CID and score &gt;= 60 and score &lt; 70)*100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 百分比 ,</p>
<p>(select count(1) from SC where CID = m.CID and score &gt;= 70 and score &lt; 85) 70-85 ,</p>
<p>cast((select count(1) from SC where CID = m.CID and score &gt;= 70 and score &lt; 85)*100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 百分比 ,</p>
<p>(select count(1) from SC where CID = m.CID and score &gt;= 85) 85-100 ,</p>
<p>cast((select count(1) from SC where CID = m.CID and score &gt;= 85)*100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 百分比</p>
<p>from Course m</p>
<p>order by m.CID</p>
<p>–纵向显示1(显示存在的分数段)</p>
<p>select m.CID 课程编号 , m.Cname 课程名称 , 分数段 = (</p>
<p>case when n.score &gt;= 85 then ‘85-100’</p>
<p>when n.score &gt;= 70 and n.score &lt; 85 then ‘70-85’</p>
<p>when n.score &gt;= 60 and n.score &lt; 70 then ‘60-70’</p>
<p>else ‘0-60’</p>
<p>end) ,</p>
<p>count(1) 数量 ,</p>
<p>cast(count(1) * 100.0 / (select count(1) from sc where CID = m.CID) as decimal(18,2)) 百分比</p>
<p>from Course m , sc n</p>
<p>where m.CID = n.CID</p>
<p>group by m.CID , m.Cname , (</p>
<p>case when n.score &gt;= 85 then ‘85-100’</p>
<p>when n.score &gt;= 70 and n.score &lt; 85 then ‘70-85’</p>
<p>when n.score &gt;= 60 and n.score &lt; 70 then ‘60-70’</p>
<p>else ‘0-60’</p>
<p>end)</p>
<p>order by m.CID , m.Cname , 分数段</p>
<p>–纵向显示2(显示存在的分数段，不存在的分数段用0显示)</p>
<p>select m.CID 课程编号 , m.Cname 课程名称 , 分数段 = (</p>
<p>case when n.score &gt;= 85 then ‘85-100’</p>
<p>when n.score &gt;= 70 and n.score &lt; 85 then ‘70-85’</p>
<p>when n.score &gt;= 60 and n.score &lt; 70 then ‘60-70’</p>
<p>else ‘0-60’</p>
<p>end) ,</p>
<p>count(1) 数量 ,</p>
<p>cast(count(1) * 100.0 / (select count(1) from sc where CID = m.CID) as decimal(18,2)) 百分比</p>
<p>from Course m , sc n</p>
<p>where m.CID = n.CID</p>
<p>group by all m.CID , m.Cname , (</p>
<p>case when n.score &gt;= 85 then ‘85-100’</p>
<p>when n.score &gt;= 70 and n.score &lt; 85 then ‘70-85’</p>
<p>when n.score &gt;= 60 and n.score &lt; 70 then ‘60-70’</p>
<p>else ‘0-60’</p>
<p>end)</p>
<p>order by m.CID , m.Cname , 分数段</p>
<p>–24、查询学生平均成绩及其名次–24.1 查询学生的平均成绩并进行排名，sql 2000用子查询完成，分平均成绩重复时保留名次空缺和不保留名次空缺两种。</p>
<p>select t1.* , px = (select count(1) from</p>
<p>(</p>
<p>select m.SID 学生编号 ,</p>
<p>m.Sname 学生姓名 ,</p>
<p>isnull(cast(avg(score) as decimal(18,2)),0) 平均成绩</p>
<p>from Student m left join SC n on m.SID = n.SID</p>
<p>group by m.SID , m.Sname</p>
<p>) t2 where 平均成绩 &gt; t1.平均成绩) + 1 from</p>
<p>(</p>
<p>select m.SID 学生编号 ,</p>
<p>m.Sname 学生姓名 ,</p>
<p>isnull(cast(avg(score) as decimal(18,2)),0) 平均成绩</p>
<p>from Student m left join SC n on m.SID = n.SID</p>
<p>group by m.SID , m.Sname</p>
<p>) t1</p>
<p>order by px</p>
<p>select t1.* , px = (select count(distinct 平均成绩) from</p>
<p>(</p>
<p>select m.SID 学生编号 ,</p>
<p>m.Sname 学生姓名 ,</p>
<p>isnull(cast(avg(score) as decimal(18,2)),0) 平均成绩</p>
<p>from Student m left join SC n on m.SID = n.SID</p>
<p>group by m.SID , m.Sname</p>
<p>) t2 where 平均成绩 &gt;= t1.平均成绩) from</p>
<p>(</p>
<p>select m.SID 学生编号 ,</p>
<p>m.Sname 学生姓名 ,</p>
<p>isnull(cast(avg(score) as decimal(18,2)),0) 平均成绩</p>
<p>from Student m left join SC n on m.SID = n.SID</p>
<p>group by m.SID , m.Sname</p>
<p>) t1</p>
<p>order by px</p>
<p>–24.2 查询学生的平均成绩并进行排名，sql 2005用rank,DENSE_RANK完成，分平均成绩重复时保留名次空缺和不保留名次空缺两种。</p>
<p>select t.* , px = rank() over(order by 平均成绩 desc) from</p>
<p>(</p>
<p>select m.SID 学生编号 ,</p>
<p>m.Sname 学生姓名 ,</p>
<p>isnull(cast(avg(score) as decimal(18,2)),0) 平均成绩</p>
<p>from Student m left join SC n on m.SID = n.SID<br>group by m.SID , m.Sname<br>) t<br>order by px<br>select t.* , px = DENSE_RANK() over(order by 平均成绩 desc) from<br>(<br>select m.SID 学生编号 ,<br>m.Sname 学生姓名 ,<br>isnull(cast(avg(score) as decimal(18,2)),0) 平均成绩<br>from Student m left join SC n on m.SID = n.SID<br>group by m.SID , m.Sname<br>) t<br>order by px</p>
<p>–25、查询各科成绩前三名的记录–25.1 分数重复时保留名次空缺<br>select m.* , n.CID , n.score from Student m, SC n where m.SID = n.SID and n.score in<br>(select top 3 score from sc where CID = n.CID order by score desc) order by n.CID , n.score desc</p>
<p>–25.2 分数重复时不保留名次空缺，合并名次</p>
<p>–sql 2000用子查询实现<br>select * from (select t.* , px = (select count(distinct score) from SC where CID = t.CID and score &gt;= t.score) from sc t) m where px between 1 and 3 order by m.Cid , m.px</p>
<p>–sql 2005用DENSE_RANK实现<br>select * from (select t.* , px = DENSE_RANK() over(partition by Cid order by score desc) from sc t) m where px between 1 and 3 order by m.CID , m.px</p>
<p>–26、查询每门课程被选修的学生数<br>select Cid , count(SID) 学生数 from sc group by CID</p>
<p>–27、查询出只有两门课程的全部学生的学号和姓名<br>select Student.SID , Student.Sname<br>from Student , SC<br>where Student.SID = SC.SID<br>group by Student.SID , Student.Sname<br>having count(SC.CID) = 2<br>order by Student.SID</p>
<p>–28、查询男生、女生人数<br>select count(Ssex) as 男生人数 from Student where Ssex = N’男’<br>select count(Ssex) as 女生人数 from Student where Ssex = N’女’<br>select sum(case when Ssex = N’男’ then 1 else 0 end) 男生人数 ,sum(case when Ssex = N’女’ then 1 else 0 end) 女生人数 from student<br>select case when Ssex = N’男’ then N’男生人数’ else N’女生人数’ end 男女情况 , count(1) 人数 from student group by case when Ssex = N’男’ then N’男生人数’ else N’女生人数’ end</p>
<p>–29、查询名字中含有”风”字的学生信息<br>select * from student where sname like N’%风%’<br>select * from student where charindex(N’风’ , sname) &gt; 0</p>
<p>–30、查询同名同性学生名单，并统计同名人数<br>select Sname 学生姓名 , count(<em>) 人数 from Student group by Sname having count(</em>) &gt; 1</p>
<p>–31、查询1990年出生的学生名单(注：Student表中Sage列的类型是datetime)<br>select * from Student where year(sage) = 1990<br>select * from Student where datediff(yy,sage,’1990-01-01’) = 0<br>select * from Student where datepart(yy,sage) = 1990<br>select * from Student where convert(varchar(4),sage,120) = ‘1990’</p>
<p>–32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列<br>select m.CID , m.Cname , cast(avg(n.score) as decimal(18,2)) avg_score<br>from Course m, SC n<br>where m.CID = n.CID<br>group by m.CID , m.Cname<br>order by avg_score desc, m.CID asc</p>
<p>–33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩<br>select a.SID , a.Sname , cast(avg(b.score) as decimal(18,2)) avg_score<br>from Student a , sc b<br>where a.SID = b.SID<br>group by a.SID , a.Sname<br>having cast(avg(b.score) as decimal(18,2)) &gt;= 85<br>order by a.SID</p>
<p>–34、查询课程名称为”数学”，且分数低于60的学生姓名和分数<br>select sname , score<br>from Student , SC , Course<br>where SC.SID = Student.SID and SC.CID = Course.CID and Course.Cname = N’数学’ and score &lt; 60</p>
<p>–35、查询所有学生的课程及分数情况<br>select Student.* , Course.Cname , SC.CID , SC.score<br>from Student, SC , Course<br>where Student.SID = SC.SID and SC.CID = Course.CID<br>order by Student.SID , SC.CID</p>
<p>–36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数<br>select Student.* , Course.Cname , SC.CID , SC.score<br>from Student, SC , Course<br>where Student.SID = SC.SID and SC.CID = Course.CID and SC.score &gt;= 70<br>order by Student.SID , SC.CID</p>
<p>–37、查询不及格的课程<br>select Student.* , Course.Cname , SC.CID , SC.score<br>from Student, SC , Course<br>where Student.SID = SC.SID and SC.CID = Course.CID and SC.score &lt; 60<br>order by Student.SID , SC.CID</p>
<p>–38、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名<br>select Student.* , Course.Cname , SC.CID , SC.score<br>from Student, SC , Course<br>where Student.SID = SC.SID and SC.CID = Course.CID and SC.CID = ‘01’ and SC.score &gt;= 80<br>order by Student.SID , SC.CID</p>
<p>–39、求每门课程的学生人数<br>select Course.CID , Course.Cname , count(*) 学生人数<br>from Course , SC<br>where Course.CID = SC.CID<br>group by Course.CID , Course.Cname<br>order by Course.CID , Course.Cname</p>
<p>–40、查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩–40.1 当最高分只有一个时<br>select top 1 Student.* , Course.Cname , SC.CID , SC.score<br>from Student, SC , Course , Teacher<br>where Student.SID = SC.SID and SC.CID = Course.CID and Course.TID = Teacher.TID and Teacher.Tname = N’张三’<br>order by SC.score desc</p>
<p>–40.2 当最高分出现多个时<br>select Student.* , Course.Cname , SC.CID , SC.score<br>from Student, SC , Course , Teacher<br>where Student.SID = SC.SID and SC.CID = Course.CID and Course.TID = Teacher.TID and Teacher.Tname = N’张三’ and<br>SC.score = (select max(SC.score) from SC , Course , Teacher where SC.CID = Course.CID and Course.TID = Teacher.TID and Teacher.Tname = N’张三’)</p>
<p>–41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩<br>–方法1<br>select m.* from SC m ,(select CID , score from SC group by CID , score having count(1) &gt; 1) n<br>where m.CID= n.CID and m.score = n.score order by m.CID , m.score , m.SID</p>
<p>–方法2<br>select m.* from SC m where exists (select 1 from (select CID , score from SC group by CID , score having count(1) &gt; 1) n<br>where m.CID= n.CID and m.score = n.score) order by m.CID , m.score , m.SID</p>
<p>–42、查询每门功成绩最好的前两名<br>select t.* from sc t where score in (select top 2 score from sc where CID = T.CID order by score desc) order by t.CID , t.score desc</p>
<p>–43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列<br>select Course.CID , Course.Cname , count(<em>) 学生人数<br>from Course , SC<br>where Course.CID = SC.CID<br>group by Course.CID , Course.Cname<br>having count(</em>) &gt;= 5<br>order by 学生人数 desc , Course.CID</p>
<p>–44、检索至少选修两门课程的学生学号<br>select student.SID , student.Sname<br>from student , SC<br>where student.SID = SC.SID<br>group by student.SID , student.Sname<br>having count(1) &gt;= 2<br>order by student.SID</p>
<p>–45、查询选修了全部课程的学生信息<br>–方法1 根据数量来完成<br>select student.* from student where SID in<br>(select SID from sc group by SID having count(1) = (select count(1) from course))</p>
<p>–方法2 使用双重否定来完成<br>select t.* from student t where t.SID not in<br>(<br>select distinct m.SID from<br>(<br>select SID , CID from student , course<br>) m where not exists (select 1 from sc n where n.SID = m.SID and n.CID = m.CID)<br>)</p>
<p>–方法3 使用双重否定来完成<br>select t.* from student t where not exists(select 1 from<br>(<br>select distinct m.SID from<br>(<br>select SID , CID from student , course<br>) m where not exists (select 1 from sc n where n.SID = m.SID and n.CID = m.CID)<br>) k where k.SID = t.SID<br>)</p>
<p>–46、查询各学生的年龄–46.1 只按照年份来算<br>select * , datediff(yy , sage , getdate()) 年龄 from student</p>
<p>–46.2 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一<br>select * , case when right(convert(varchar(10),getdate(),120),5) &lt; right(convert(varchar(10),sage,120),5) then datediff(yy , sage , getdate()) - 1 else datediff(yy , sage , getdate()) end 年龄 from student</p>
<p>–47、查询本周过生日的学生<br>select * from student where datediff(week,datename(yy,getdate()) + right(convert(varchar(10),sage,120),6),getdate()) = 0</p>
<p>–48、查询下周过生日的学生<br>select * from student where datediff(week,datename(yy,getdate()) + right(convert(varchar(10),sage,120),6),getdate()) = -1</p>
<p>–49、查询本月过生日的学生<br>select * from student where datediff(mm,datename(yy,getdate()) + right(convert(varchar(10),sage,120),6),getdate()) = 0</p>
<p>–50、查询下月过生日的学生<br>select * from student where datediff(mm,datename(yy,getdate()) + right(convert(varchar(10),sage,120),6),getdate()) = -1</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jun-Gui</p>
  <div class="site-description" itemprop="description">纵有疾风起，人生不言弃！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jun-Gui</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">113k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:43</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
   <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
